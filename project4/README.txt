一、SM3.cpp：SM3的基本软件实现，未进行优化，主要函数如下：
	1. Init_T()
	功能：初始化SM3算法中使用的T常量表。

	2. P0(x), P1(x)
	功能：SM3定义的两个置换函数，用于消息扩展和压缩函数内部状态更新。

	3. FF(x,y,z,j), GG(x,y,z,j)
	功能：SM3定义的布尔函数，用于压缩函数中的状态更新。j<16和j>=16时采用不同逻辑。

	4. message_expand(block, W, W1)
	功能：对每个512位消息块进行消息扩展，生成68个W和64个W1子消息。

	5. CF(V, block)
	功能：SM3核心压缩函数，对单个512位消息块进行64轮迭代，更新内部状态V。

	6. SM3(message, message_len, digest)
	功能：完整的SM3哈希计算流程：
	- 自动完成填充
	- 按块迭代调用压缩函数
	- 输出256位哈希结果digest
二、unroll.cpp：采用循环展开和寄存器优化技术提升单条消息哈希计算性能。该实现去除压缩函数的循环控制，全部64轮手工展开，状态变量使用局部寄存器变量，减少函数调用和内存访问。
性能提升：未优化时，基本的SM3效率为约 37 MB/s，优化后达到了 50 MB/s

三、length-extension attack.cpp：实现对SM3的长度扩展攻击验证，构造 “原始消息 || 填充 || 扩展消息” 的伪造输入；验证攻击者仅凭原始哈希值，即可伪造正确的扩展哈希。
	在主函数中：
	1. 定义原始消息 M = "attack at dawn"，并计算其 SM3 哈希值；
	2. 定义扩展消息 extension = " and dusk"，模拟攻击者要追加的内容；
	3. 构造伪造消息 M||padding||extension，并用 sm3 直接计算哈希作为对照；
	4. 恢复原始哈希 H(M) 对应的中间状态 V；
	5. 使用 CF 函数对扩展数据进行压缩，得到 H(M||padding||extension)；
	6. 比较直接计算的哈希值与攻击者构造出的哈希值是否一致；
	7. 若攻击成功，输出“Length-extension attack verified”。

四、sm3_merkle.cpp：基于SM3哈希算法的RFC6962 Merkle树构建与验证，包含叶子节点的存在性证明和不存在性证明
	1、sm3_hash()：sm3的封装，方便调用。
	2、LeafHash()：计算叶子节点哈希，格式为0x00前缀加数据。
	3、NodeHash()：计算父节点哈希，格式为0x01前缀加左右子节点哈希拼接。
	4、build_merkle_tree()：迭代构建Merkle树，返回根哈希。
	5、generate_proof()：生成指定叶子节点的存在性证明路径。
	6、verify_proof()：验证存在性证明，确认叶子是否属于Merkle树。
	7、find_neighbor_indices()：查找给定目标值在排序叶子中的左右邻近索引，用于不存在性证明。
	8、verify_non_inclusion()：验证不存在性证明，判断目标值是否在两个邻近叶子之间且邻居存在。
	9、main函数中：
		随机生成10万个32字节叶子节点数据，进行字典序排序；
		计算叶子节点的SM3哈希并构造Merkle树，输出根哈希；
		随机抽取一个叶子测试存在性证明及验证，输出验证结果；
		随机生成一个目标数据，测试不存在性证明及验证，输出验证结果及相关信息。